import { computed, inject } from '@angular/core';
import {
  patchState,
  signalStore,
  withComputed,
  withMethods,
  withState,
} from '@ngrx/signals';
import { rxMethod } from '@ngrx/signals/rxjs-interop';
import { tapResponse } from '@ngrx/operators';
import { pipe, switchMap, tap, map } from 'rxjs';

import { WellName } from '../models/well-name.model';
import { WellDetails } from '../models/well-details.model';
import { WellboreDiagramData } from '../models/wellbore-diagram.model';
import { WellDataService } from '../services/well-data.service';
import { sortCasingsByDepthDesc } from '../../shared/utils/wellbore-math.util';

interface WellState {
  readonly wellNames: WellName[];
  readonly selectedEpANum: number | null;
  readonly wellDetails: WellDetails | null;
  readonly loading: boolean;
  readonly error: string | null;
  readonly animationTrigger: number;
}

const initialState: WellState = {
  wellNames: [],
  selectedEpANum: null,
  wellDetails: null,
  loading: false,
  error: null,
  animationTrigger: 0,
};

export const WellStore = signalStore(
  { providedIn: 'root' },
  withState<WellState>(initialState),

  withComputed(({ wellDetails, wellNames }) => ({

    uniqueWellNames: computed(() => {
      const seen = new Set<string>();
      return wellNames().filter((w) => {
        if (seen.has(w.wellName)) return false;
        seen.add(w.wellName);
        return true;
      });
    }),

    isLoaded: computed(() => wellDetails() !== null),

    totalDepth: computed(
      () => wellDetails()?.EXAD_RCD_PREWAP?.[0]?.estTargetDepth ?? 4000,
    ),

    diagramData: computed((): WellboreDiagramData | null => {
      const d = wellDetails();
      if (!d) return null;
      return {
        wellName: d.WELL_MASTER?.[0]?.well ?? '',
        totalDepth: d.EXAD_RCD_PREWAP?.[0]?.estTargetDepth ?? 4000,
        casings: sortCasingsByDepthDesc(d.EXAD_GWD_IR_CASING ?? []),
        geologicTops: [...(d.EXAD_GWD_IR_TOPS ?? [])].sort(
          (a, b) => a.planTvdDepth - b.planTvdDepth,
        ),
        hydrogeology: d.EXAD_GWD_IR_HYDROGEOLOGY?.[0] ?? null,
        prewap: d.EXAD_RCD_PREWAP?.[0] ?? null,
        rigActivity: d.RIG_ACTIVITY?.[0] ?? null,
        currentDepth:
          d.DRLG_OP_STATUS?.[0]?.wPrsntDpth ??
          d.EXAD_RCD_PREWAP?.[0]?.estTargetDepth ??
          0,
      };
    }),
  })),

  withMethods((store, wellDataService = inject(WellDataService)) => {
    
    // Define selectWell locally so it can be safely called by loadWellNames
    const selectWell = rxMethod<number>(
      pipe(
        tap((epANum) =>
          patchState(store, {
            selectedEpANum: epANum,
            loading: true,
            error: null,
          }),
        ),
        switchMap((epANum) =>
          wellDataService.getWellDetails(epANum).pipe(
            tapResponse({
              next: (wellDetails) =>
                patchState(store, {
                  wellDetails,
                  loading: false,
                  animationTrigger: store.animationTrigger() + 1,
                }),
              error: (err: Error) =>
                patchState(store, {
                  error: err.message ?? 'Failed to load well details',
                  loading: false,
                }),
            }),
          ),
        ),
      ),
    );

    const loadWellNames = rxMethod<void>(
      pipe(
        tap(() => patchState(store, { loading: true, error: null })),
        switchMap(() =>
          wellDataService.getMorningReport().pipe(
            // Map the MorningReport[] to our existing WellName[] structure
            map((reports) => 
              reports.map((report) => ({
                wellName: report.wGnrName,
                epANum: Number(report.epANum)
              }))
            ),
            tapResponse({
              next: (wellNames) => {
                patchState(store, { wellNames, loading: false });
                
                // Safely trigger selectWell on the first item to avoid a blank screen
                if (wellNames.length > 0 && !store.selectedEpANum()) {
                  selectWell(wellNames[0].epANum);
                }
              },
              error: (err: Error) =>
                patchState(store, {
                  error: err.message ?? 'Failed to load well names',
                  loading: false,
                }),
            }),
          ),
        ),
      ),
    );

    // Export the methods to the store
    return {
      selectWell,
      loadWellNames,
    };
  }),
);
===
$chip-bg:            #1e2640;
$chip-border:        #2e3c60;
$chip-text:          #7a8fb5;
$chip-active-bg:     #1a5cbf;
$chip-active-border: #4a8edf;
$strip-bg:           #141929;
$accent:             #4a8edf;

.chip-strip {
  display: flex;
  align-items: center;
  justify-content: center; /* This centers the chips horizontally */
  flex-wrap: wrap;
  gap: 8px;
  padding: 10px 20px;
  background: $strip-bg;
  border-bottom: 1px solid #1d2540;

  &__label {
    font-size: 10px;
    font-weight: 700;
    letter-spacing: 1.2px;
    text-transform: uppercase;
    color: #404e72;
    margin-right: 4px;
    flex-shrink: 0;
  }
}

.chip {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 5px 14px 5px 10px;
  border-radius: 20px;
  border: 1.5px solid $chip-border;
  background: $chip-bg;
  color: $chip-text;
  font-family: inherit;
  font-size: 12px;
  font-weight: 600;
  letter-spacing: 0.4px;
  cursor: pointer;
  outline: none;
  transition:
    background 0.18s ease,
    border-color 0.18s ease,
    color 0.18s ease,
    box-shadow 0.18s ease,
    transform 0.12s ease;

  &:hover {
    background: #263156;
    border-color: $accent;
    color: #c0d4f5;
    transform: translateY(-1px);
  }

  &:focus-visible {
    box-shadow: 0 0 0 3px rgba($accent, 0.4);
  }

  &:active {
    transform: translateY(0);
  }

  &--active {
    background: $chip-active-bg;
    border-color: $chip-active-border;
    color: #ffffff;
    box-shadow: 0 2px 10px rgba(26, 92, 191, 0.55);

    .chip__dot {
      background: #7ef0a0;
      box-shadow: 0 0 5px #7ef0a0;
    }
  }

  &__dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: #404e72;
    flex-shrink: 0;
    transition: background 0.2s, box-shadow 0.2s;
  }
}
