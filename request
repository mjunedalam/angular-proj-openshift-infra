import { signalStore, withState, withMethods, patchState } from '@ngrx/signals';
import { computed, inject } from '@angular/core';
import { MoriningReportService } from '../../../services/morining-report.service'
import { MorningReport } from '../../../models/morining-report.model';

interface MorningReportState {
    wells: MorningReport[];
    startIndex: number;
    selectedWellId: string | null;
    chipsPerPage: number;
}


export const MorningReportStore = signalStore(
    { providedIn: 'root' },
    withState<MorningReportState>({
        wells: [],
        startIndex: 0,
        selectedWellId: null,
        chipsPerPage: 5,
    }),
    withMethods((store, service = inject(MoriningReportService)) => ({
        loadMorningReportData() {
            service.getMorningReport().subscribe({
                next: (wells) => {
                    patchState(store, { wells });
                    if (wells.length > 0) {
                        patchState(store, { selectedWellId: wells[0].epANum });
                    }
                },
            });
        },
        selectWell(id: string) {
            patchState(store, { selectedWellId: id });
        },
        navigateNext() {
            const wells = store.wells();
            const selectedId = store.selectedWellId();
            const chipsPerPage = store.chipsPerPage();
            const startIndex = store.startIndex();
            const endIndex = startIndex + chipsPerPage;
            const currentIndex = wells.findIndex(w => w.epANum === selectedId);

            // If currently selected chip is the **last visible chip**
            if (currentIndex === endIndex - 1) {
                // Move to next page
                const newStartIndex = Math.min(startIndex + chipsPerPage, wells.length - chipsPerPage);
                const newVisibleWells = wells.slice(newStartIndex, newStartIndex + chipsPerPage);
                patchState(store, {
                    startIndex: newStartIndex,
                    selectedWellId: newVisibleWells[0]?.epANum,
                });
            } else {
                // Move to next chip in list
                const nextIndex = Math.min(currentIndex + 1, wells.length - 1);
                patchState(store, {
                    selectedWellId: wells[nextIndex]?.epANum,
                });
            }
        },

        navigatePrev() {
            const wells = store.wells();
            const selectedId = store.selectedWellId();
            const chipsPerPage = store.chipsPerPage();
            const startIndex = store.startIndex();
            const currentIndex = wells.findIndex(w => w.epANum === selectedId);

            // If currently selected chip is the **first visible chip**
            if (currentIndex === startIndex) {
                // Move to previous page
                const newStartIndex = Math.max(startIndex - chipsPerPage, 0);
                const newVisibleWells = wells.slice(newStartIndex, newStartIndex + chipsPerPage);
                patchState(store, {
                    startIndex: newStartIndex,
                    selectedWellId: newVisibleWells[newVisibleWells.length - 1]?.epANum,
                });
            } else {
                // Move to previous chip in list
                const prevIndex = Math.max(currentIndex - 1, 0);
                patchState(store, {
                    selectedWellId: wells[prevIndex]?.epANum,
                });
            }
        },
        visibleWells: computed(() => {
            const wells = store.wells() || [];
            const start = store.startIndex();
            const count = store.chipsPerPage();
            return wells.slice(start, start + count);
        }),

        selectedWell: computed(() => {
            const wells = store.wells() || [];
            const selectedId = store.selectedWellId();
            return wells.find(well => well.epANum === selectedId);
        }),
    }))
)

