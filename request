interface MorningReportState {
    wells: MorningReport[];
    startIndex: number;
    selectedWellId: string | null;
    chipsPerPage: number;
    showAll: boolean; // New state property
}

export const MorningReportStore = signalStore(
    { providedIn: 'root' },
    withState<MorningReportState>({
        wells: [],
        startIndex: 0,
        selectedWellId: null,
        chipsPerPage: 5,
        showAll: false, // Default to paginated view
    }),
    withMethods((store, service = inject(MoriningReportService)) => ({
        loadMorningReportData() {
            service.getMorningReport().subscribe({
                next: (wells) => {
                    patchState(store, { wells });
                    if (wells.length > 0 && !store.selectedWellId()) {
                        patchState(store, { selectedWellId: wells[0].epANum });
                    }
                },
            });
        },

        selectWell(id: string) {
            patchState(store, { selectedWellId: id });
        },

        toggleShowAll() {
            patchState(store, { showAll: !store.showAll() });
        },

        navigateNext() {
            const wells = store.wells();
            const currentId = store.selectedWellId();
            const currentIndex = wells.findIndex((w) => w.epANum === currentId);

            if (currentIndex < wells.length - 1) {
                const nextIndex = currentIndex + 1;
                const currentStart = store.startIndex();
                
                // Only shift pagination if we aren't in "Show All" mode
                if (!store.showAll() && nextIndex >= currentStart + store.chipsPerPage()) {
                    patchState(store, { startIndex: currentStart + 1 });
                }
                patchState(store, { selectedWellId: wells[nextIndex].epANum });
            }
        },

        navigatePrev() {
            const wells = store.wells();
            const currentId = store.selectedWellId();
            const currentIndex = wells.findIndex((w) => w.epANum === currentId);

            if (currentIndex > 0) {
                const prevIndex = currentIndex - 1;
                const currentStart = store.startIndex();

                if (!store.showAll() && prevIndex < currentStart) {
                    patchState(store, { startIndex: Math.max(0, currentStart - 1) });
                }
                patchState(store, { selectedWellId: wells[prevIndex].epANum });
            }
        },
    })),
    withMethods((store) => ({
        visibleWells: computed(() => {
            const wells = store.wells();
            if (store.showAll()) {
                return wells; // Return everything
            }
            const start = store.startIndex();
            return wells.slice(start, start + store.chipsPerPage());
        }),
        selectedWell: computed(() => {
            return store.wells().find((w) => w.epANum === store.selectedWellId());
        })
    }))
);
